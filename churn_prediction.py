# -*- coding: utf-8 -*-
"""churn_prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JTRdfoSWidYuVjIEpiLNJLpvEJHLZj0d

##Load data
"""

from google.colab import files
uploaded = files.upload()

"""Load the csv to pandas

"""

import pandas as pd
df = pd.read_csv('train.csv')
df.head()

"""check the dataset size and structure"""

df.shape

df.columns

df.info()

df.isnull().sum()



df.describe()

df['churn'].value_counts()

"""##EDA (To gain key insights)

##Visualization (to see how many customers churned)
"""

import matplotlib.pyplot as plt

df['churn'].value_counts().plot(kind='bar', color=['skyblue', 'salmon'])
plt.title('Customer Churn Distribution')
plt.xlabel('Churn')
plt.ylabel('Number of Customers')
plt.xticks(rotation=0)
plt.show()

"""## Categorical Features vs Churn

"""

import seaborn as sns
import matplotlib.pyplot as plt

# Plot for international_plan
sns.countplot(x='international_plan', hue='churn', data=df)
plt.title('Churn by International Plan')
plt.show()

# Plot for voice_mail_plan
sns.countplot(x='voice_mail_plan', hue='churn', data=df)
plt.title('Churn by Voicemail Plan')
plt.show()

"""##Numeric Features vs Churn

1) total_day_minutes vs Churn ( total daytime calls )
"""

sns.boxplot(x='churn', y='total_day_minutes', data=df)
plt.title('Total Day Minutes vs Churn')
plt.show()

"""2) number_customer_service_calls vs churn"""

sns.boxplot(x='churn', y='number_customer_service_calls', data=df)
plt.title('Customer Service Calls vs Churn')
plt.show()

"""3) total_intl_charge vs churn"""

sns.boxplot(x='churn', y='total_intl_charge', data=df)
plt.title('International Charges vs Churn')
plt.show()

"""##Data Preprocessing

##Converting strings yes/no to 1/0
Because ML algorithms cannot understand text and only work with numbers
"""

df['international_plan'] = df['international_plan'].map({'yes': 1, 'no' : 0})
df['voice_mail_plan'] = df['voice_mail_plan'].map({'yes' : 1, 'no' : 0})
df['churn'] = df['churn'].map({'yes': 1, 'no': 0}) #target column

df.info()

"""Drop irrelevant columns like state, area code"""

df = df.drop(['state', 'area_code'], axis = 1)

df.columns

df.isnull().sum()

"""##Data Splitting and Model (Logistic Regression)"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from imblearn.over_sampling import SMOTE

X = df.drop('churn', axis=1)
y = df['churn']

X_train, X_test, y_train, y_test = train_test_split(X,y,test_size=0.2, random_state=42)
sm = SMOTE(random_state=42)
X_train_res, y_train_res = sm.fit_resample(X_train, y_train)

model = LogisticRegression(max_iter=1000)
model.fit(X_train_res, y_train_res)

"""##Prediction and Accuracy"""

y_pred = model.predict(X_test)

from sklearn.metrics import accuracy_score

accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

from sklearn.metrics import confusion_matrix, classification_report

print("Confusion Matrix:")
print(confusion_matrix(y_test, y_pred))

print("\nClassification Report:")
print(classification_report(y_test, y_pred))

"""##Random Forest (Model)"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix

# 1. Initialize the model
rf_model = RandomForestClassifier(n_estimators=100, random_state=42)

# 2. Train the model on SMOTE-resampled data
rf_model.fit(X_train_res, y_train_res)

# 3. Predict on the test data
y_pred_rf = rf_model.predict(X_test)

# 4. Print confusion matrix
print("Confusion Matrix:")
print(confusion_matrix(y_test, y_pred_rf))

# 5. Print classification report
print("\nClassification Report:")
print(classification_report(y_test, y_pred_rf))

"""Accuracy for Random Forest"""

from sklearn.metrics import accuracy_score

accuracy = accuracy_score(y_test, y_pred_rf)
print(f"\nAccuracy: {accuracy:.2f}")

"""#Save the trained model"""

import joblib

# Save the model to a file
joblib.dump(rf_model, 'random_forest_model.pkl')

"""Load the data"""

# Load the model again (to check)
loaded_model = joblib.load('random_forest_model.pkl')

# Use it to predict
pred = loaded_model.predict(X_test)
print(pred[:10])  # show first 10 predictions

"""Save the SMOTE- preprocessed data"""

import pandas as pd

X_train_res['churn'] = y_train_res
X_train_res.to_csv("resampled_train_data.csv", index=False)